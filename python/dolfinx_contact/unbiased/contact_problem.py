from typing import Optional, Tuple, Union
from dolfinx import common, fem, cpp
from dolfinx import mesh as _mesh
import numpy as np
import numpy.typing as npt
import ufl
from dolfinx.cpp.graph import AdjacencyList_int32

import dolfinx_contact
import dolfinx_contact.cpp

from .nitsche_unbiased import setup_newton_solver, get_problem_parameters


class ContactProblem:
    __slots__ = ["F", "J", "bcs", "u", "du", "contact", "markers", "entities",
                 "q_deg", "coeffs", "consts", "raytracing", "newton_options",
                 "petsc_options"]

    def __init__(self, F: ufl.Form, J: ufl.Form,
                 bcs: Tuple[npt.NDArray[np.int32], list[Union[fem.Function, fem.Constant]]],
                 u: fem.Function, du: fem.Function, contact: dolfinx_contact.cpp.Contact,
                 markers: list[_mesh.MeshTags], entities: list[npt.NDArray[np.int32]],
                 quadrature_degree: int, const_coeffs: list[npt.NDArray[np.float64]],
                 consts: npt.NDArray[np.float64], raytracing: bool,
                 petsc_options: Optional[dict] = None, newton_options: Optional[dict] = None,):

        self.F = F
        self.J = J
        self.bcs = bcs
        self.u = u
        self.du = du
        self.contact = contact
        self.markers = markers
        self.entities = entities
        self.q_deg = quadrature_degree
        self.coeffs = const_coeffs
        self.consts = consts
        self.raytracing = raytracing
        self.newton_options = newton_options
        self.petsc_options = petsc_options

    def solve(self):
        newton_solver = setup_newton_solver(self.F, self.J, self.bcs, self.u, self.du, self.contact, self.markers,
                                            self.entities, self.q_deg, self.coeffs, self.consts,
                                            self.raytracing, False)
        # Set Newton solver options
        newton_solver.set_newton_options(self.newton_options)

        # Set Krylov solver options
        newton_solver.set_krylov_options(self.petsc_options)
        n, converged = newton_solver.solve(self.du)
        if not converged:
            print("Newton solver did not converge")
        return n


def create_contact_solver(ufl_form: ufl.Form, u: fem.Function,
                          markers: list[_mesh.MeshTags],
                          contact_data: Tuple[AdjacencyList_int32, list[Tuple[int, int]]],
                          bcs: Tuple[npt.NDArray[np.int32], list[Union[fem.Function, fem.Constant]]],
                          problem_parameters: dict[str, np.float64],
                          raytracing: bool,
                          quadrature_degree: int = 5,
                          form_compiler_options: Optional[dict] = None,
                          jit_options: Optional[dict] = None,
                          petsc_options: Optional[dict] = None,
                          newton_options: Optional[dict] = None,
                          search_radius: np.float64 = np.float64(-1.)) -> ContactProblem:
    """
    Use custom kernel to compute the contact problem with two elastic bodies coming into contact.

    Parameters
    ==========
    ufl_form: The variational form without contact contribution
    u:        The function to be solved for. Also serves as initial value.
    markers
        A list of meshtags. The first element must mark all separate objects in order to create the correct nullspace.
        The second element must contain the mesh_tags for all puppet surfaces,
        Dirichlet-surfaces and Neumann-surfaces
        All further elements may contain candidate_surfaces
    contact_data = (surfaces, contact_pairs), where
        surfaces: Adjacency list. Links of i are meshtag values for contact
                  surfaces in ith mesh_tag in mesh_tags
        contact_pairs: list of pairs (i, j) marking the ith surface as a puppet
                  surface and the jth surface as the corresponding candidate
                  surface
    problem_parameters
        Dictionary with lame parameters and Nitsche parameters.
        Valid (key, value) tuples are: ('gamma': float), ('theta', float), ('mu', float),
        (lambda, float),
        where theta can be -1, 0 or 1 for skew-symmetric, penalty like or symmetric
        enforcement of Nitsche conditions
    quadrature_degree
        The quadrature degree to use for the custom contact kernels
    form_compiler_options
        Parameters used in FFCX compilation of this form. Run `ffcx --help` at
        the commandline to see all available options. Takes priority over all
        other parameter values, except for `scalar_type` which is determined by
        DOLFINX.
    jit_options
        Parameters used in CFFI JIT compilation of C code generated by FFCX.
        See https://github.com/FEniCS/dolfinx/blob/main/python/dolfinx/jit.py
        for all available parameters. Takes priority over all other parameter values.
    petsc_options
        Parameters that is passed to the linear algebra backend
        PETSc. For available choices for the 'petsc_options' kwarg,
        see the `PETSc-documentation
        <https://petsc4py.readthedocs.io/en/stable/manual/ksp/>`
    newton_options
        Dictionary with Newton-solver options. Valid (key, item) tuples are:
        ("atol", float), ("rtol", float), ("convergence_criterion", "str"),
        ("max_it", int), ("error_on_nonconvergence", bool), ("relaxation_parameter", float)

    """
    form_compiler_options = {} if form_compiler_options is None else form_compiler_options
    jit_options = {} if jit_options is None else jit_options
    petsc_options = {} if petsc_options is None else petsc_options
    newton_options = {} if newton_options is None else newton_options
    mu, lmbda, theta, gamma, sigma, s = get_problem_parameters(problem_parameters)

    # Search mode
    search_method = dolfinx_contact.cpp.ContactMode.Raytracing if raytracing \
        else dolfinx_contact.cpp.ContactMode.ClosestPoint

    # Contact data
    contact_pairs = contact_data[1]
    contact_surfaces = contact_data[0]

    # Mesh, function space and FEM functions
    V = u.function_space
    mesh = V.mesh
    v = ufl_form.arguments()[0]  # Test function
    w = ufl.TrialFunction(V)     # Trial function
    du = fem.Function(V)
    du.x.array[:] = u.x.array[:]
    u.x.array[:].fill(0)
    h = ufl.CellDiameter(mesh)
    n = ufl.FacetNormal(mesh)

    # Integration measure and ufl part of linear/bilinear form
    ds = ufl.Measure("ds", domain=mesh, subdomain_data=markers[1])

    # ufl part of contact
    for contact_pair in contact_pairs:
        surface_value = int(contact_surfaces.links(0)[contact_pair[0]])
        ufl_form += - 0.5 * theta * h / gamma * ufl.inner(sigma(u) * n, sigma(v) * n) * \
            ds(surface_value)
    F = ufl.replace(ufl_form, {u: u + du})
    J = ufl.derivative(F, du, w)

    # compiled forms for rhs and tangen system
    F_custom = fem.form(F, form_compiler_options=form_compiler_options, jit_options=jit_options)
    J_custom = fem.form(J, form_compiler_options=form_compiler_options, jit_options=jit_options)

    # create contact class
    markers_cpp = [marker._cpp_object for marker in markers[1:]]
    with common.Timer("~Contact: Init"):
        contact = dolfinx_contact.cpp.Contact(markers_cpp, contact_surfaces, contact_pairs,
                                              V._cpp_object, quadrature_degree=quadrature_degree,
                                              search_method=search_method)

    contact.set_search_radius(search_radius)

    # pack constants
    consts = np.array([gamma, theta], dtype=np.float64)

    # Pack material parameters mu and lambda on each contact surface
    with common.Timer("~Contact: Interpolate coeffs (mu, lmbda)"):
        V2 = fem.FunctionSpace(mesh, ("DG", 0))
        lmbda2 = fem.Function(V2)
        lmbda2.interpolate(lambda x: np.full((1, x.shape[1]), lmbda))
        mu2 = fem.Function(V2)
        mu2.interpolate(lambda x: np.full((1, x.shape[1]), mu))
        fric_coeff = fem.Function(V2)
        fric_coeff.interpolate(lambda x: np.full((1, x.shape[1]), s))

    # Retrieve active entities
    entities = []
    with common.Timer("~Contact: Compute active entities"):
        for pair in contact_pairs:
            entities.append(contact.active_entities(pair[0]))

    # Pack material parameters
    material = []
    with common.Timer("~Contact: Pack coeffs (mu, lmbda"):
        for i in range(len(contact_pairs)):
            material.append(np.hstack([dolfinx_contact.cpp.pack_coefficient_quadrature(
                mu2._cpp_object, 0, entities[i]),
                dolfinx_contact.cpp.pack_coefficient_quadrature(
                lmbda2._cpp_object, 0, entities[i]),
                dolfinx_contact.cpp.pack_coefficient_quadrature(
                fric_coeff._cpp_object, 0, entities[i])]))

    # Pack celldiameter on each surface
    h_packed = []
    with common.Timer("~Contact: Compute and pack celldiameter"):
        surface_cells = np.unique(np.hstack([entities[i][:, 0] for i in range(len(contact_pairs))]))
        h_int = fem.Function(V2)
        expr = fem.Expression(h, V2.element.interpolation_points())
        h_int.interpolate(expr, surface_cells)
        for i in range(len(contact_pairs)):
            h_packed.append(dolfinx_contact.cpp.pack_coefficient_quadrature(
                h_int._cpp_object, 0, entities[i]))

    # Concatenate material parameters, h
    const_coeffs = []
    for i in range(len(contact_pairs)):
        const_coeffs.append(np.hstack([material[i], h_packed[i]]))

    problem = ContactProblem(F_custom, J_custom, bcs, u, du, contact, markers, entities,
                             quadrature_degree, const_coeffs, consts, raytracing,
                             newton_options, petsc_options)

    return problem
